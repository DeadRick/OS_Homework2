# Демьяненко Виктор Николаевич БПИ217
## Домашнее задание по ОС #2
## Вариант 29

## Условие задачи:

Первая военная задача. Темной–темной ночью прапорщики Иванов, Петров и Нечепорук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и
отличниками боевой и строевой подготовки, прапорщики ввели разделение труда. Иванов выносит имущество со склада и передает его
в руки Петрову, который грузит его в грузовик. Нечепорук стоит на
шухере и заодно подсчитывает рыночную стоимость добычи поле
погрузки в грузовик очередной партии похищенного. Требуется
создать приложение, моделирующее деятельность прапорщиков. Время выполнения каждого действия прапорщиков–
процессов задавать случайным образом.

## Выполненное условие:

- 4 балла ✓
- 5 балла ✓

## Сценарий задачи:

Программа должна моделировать деятельность трех прапорщиков (Иванова, Петрова и Нечепорука) при хищении военного имущества со склада. Иванов отвечает за вынос имущества со склада и передачу его Петрову, который загружает имущество в грузовик. Нечепорук отслеживает рыночную стоимость добычи при погрузке в грузовик. Каждый из прапорщиков выполняет свои действия в отдельном дочернем процессе.

## Схема решения 

Для взаимодействия между процессами будет использоваться разделяемая память в стандарте POSIX. Прапорщики будут обмениваться данными о состоянии операций (вынос, загрузка, подсчет стоимости) через разделяемую память, используя неименованные POSIX семафоры для синхронизации доступа к разделяемой памяти.

## Завершение программы и удаление ресурсов

- Программа будет завершаться, когда все процессы прапорщиков успешно выполнят свои действия или при прерывании с клавиатуры по соответствующему сигналу (например, Ctrl+C). При завершении программы будет предусмотрено корректное удаление разделяемой памяти и семафоров.
- Разделяемая память и семафоры будут корректно удалены при завершении программы или при обработке сигнала прерывания с клавиатуры. Это будет выполнено с использованием функций удаления разделяемой памяти и семафоров, предусмотренных в стандарте POSIX.

## ! ! ! ВАЖНО ! ! !

- В данной программе нет входных данных, то есть предполагается, что данные сами будут генерироваться. 
- Также важно понимать, что unsleep() - функция, чтобы можно было использовать "Ctrl + C", чтобы посмотреть корректность завершения программы. Также это чисто косметическая функция, не влияющая на результат программы. Добавил unsleep() для красоты вывода данных, чтобы можно было лучше рассмотреть процедуру выполнения программы с использованием семафоров.


## Код программы на языке С (5 баллов):

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <semaphore.h>
#include <sys/wait.h>

#define MAX_STOLEN_ITEMS 10 // Максимальное количество похищенного имущества

typedef struct {
    int items; // Количество похищенного имущества
    int value; // Рыночная стоимость похищенного имущества
} StolenGoods;

int main() {
    // Удаление существующего именованного POSIX семафора, если он существует
    sem_unlink("/my_semaphore");

    // Создание именованного POSIX семафора
    sem_t *semaphore = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);

    // Проверка на корректность семафора
    if (semaphore == SEM_FAILED) {
        perror("Ошибка создания семафора");
        exit(EXIT_FAILURE);
    }

    // Создание разделяемой памяти для хранения похищенного имущества
    int shm_fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0644);
    if (shm_fd == -1) {
        perror("Ошибка создания разделяемой памяти");
        sem_unlink("/my_semaphore");
        sem_close(semaphore);
        exit(EXIT_FAILURE);
    }
    ftruncate(shm_fd, sizeof(StolenGoods));
    StolenGoods *stolen_goods = (StolenGoods *)mmap(NULL, sizeof(StolenGoods), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (stolen_goods == MAP_FAILED) {
        perror("Ошибка отображения разделяемой памяти");
        sem_unlink("/my_semaphore");
        sem_close(semaphore);
        shm_unlink("/my_shm");
        close(shm_fd);
        exit(EXIT_FAILURE);
    }

    // Создание дочерних процессов
    for (int i = 0; i < 3; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("Ошибка создания дочернего процесса");
            sem_unlink("/my_semaphore");
            sem_close(semaphore);
            shm_unlink("/my_shm");
            close(shm_fd);
            exit(EXIT_FAILURE);
        } else if (pid == 0) {
            // Код дочернего процесса
            srand(getpid());
            int stolen_items = 0;
            int total_value = 0;

            // Взаимодействие с использованием именованных семафоров и разделяемой памяти
            while (stolen_items < MAX_STOLEN_ITEMS) {
                // Взаимодействие с семафором: ожидание освобождения
                sem_wait(semaphore);

                // Доступ и модификация разделяемой памяти
                stolen_goods->items++;
                stolen_goods->value += rand() % 101; // Генерация случайной стоимости от 0 до 100
                            // Взаимодействие с семафором: освобождение
            sem_post(semaphore);
            
            printf("Дочерний процесс с PID %d похитил товар. Всего похищено: %d\n", getpid(), stolen_goods->items);
            
            stolen_items++;
            total_value += stolen_goods->value;
            
            // (задержка тут необязательна, но для красоты вывода данных написал, чтобы можно было лучше разглядеть параллельность процессов)
            // Задержка между похищениями
            usleep(500000); // 500 миллисекунд
        }
        
        printf("Дочерний процесс с PID %d завершил работу. Всего похищено: %d, Общая стоимость: %d\n", getpid(), stolen_goods->items, total_value);
        
        // Отсоединение от разделяемой памяти
        munmap(stolen_goods, sizeof(StolenGoods));
        close(shm_fd);
        
        exit(EXIT_SUCCESS);
    }
}

// Ожидание завершения работы всех дочерних процессов
for (int i = 0; i < 3; i++) {
    wait(NULL);
}

// Уничтожение именованного семафора и разделяемой памяти
sem_unlink("/my_semaphore");
sem_close(semaphore);
shm_unlink("/my_shm");
close(shm_fd);

return 0;

}
```

## Результаты программы:

```
Дочерний процесс с PID 188 похитил товар. Всего похищено: 1
Дочерний процесс с PID 189 похитил товар. Всего похищено: 2
Дочерний процесс с PID 190 похитил товар. Всего похищено: 3
Дочерний процесс с PID 188 похитил товар. Всего похищено: 4
Дочерний процесс с PID 189 похитил товар. Всего похищено: 5
Дочерний процесс с PID 190 похитил товар. Всего похищено: 6
Дочерний процесс с PID 188 похитил товар. Всего похищено: 7
Дочерний процесс с PID 189 похитил товар. Всего похищено: 8
Дочерний процесс с PID 190 похитил товар. Всего похищено: 9
Дочерний процесс с PID 188 похитил товар. Всего похищено: 10
Дочерний процесс с PID 189 похитил товар. Всего похищено: 11
Дочерний процесс с PID 190 похитил товар. Всего похищено: 12
Дочерний процесс с PID 188 похитил товар. Всего похищено: 13
Дочерний процесс с PID 189 похитил товар. Всего похищено: 14
Дочерний процесс с PID 190 похитил товар. Всего похищено: 15
Дочерний процесс с PID 188 похитил товар. Всего похищено: 16
Дочерний процесс с PID 189 похитил товар. Всего похищено: 17
Дочерний процесс с PID 190 похитил товар. Всего похищено: 18
Дочерний процесс с PID 188 похитил товар. Всего похищено: 19
Дочерний процесс с PID 189 похитил товар. Всего похищено: 20
Дочерний процесс с PID 190 похитил товар. Всего похищено: 21
Дочерний процесс с PID 188 похитил товар. Всего похищено: 22
Дочерний процесс с PID 189 похитил товар. Всего похищено: 23
Дочерний процесс с PID 190 похитил товар. Всего похищено: 24
Дочерний процесс с PID 188 похитил товар. Всего похищено: 25
Дочерний процесс с PID 189 похитил товар. Всего похищено: 26
Дочерний процесс с PID 190 похитил товар. Всего похищено: 27
Дочерний процесс с PID 188 похитил товар. Всего похищено: 28
Дочерний процесс с PID 189 похитил товар. Всего похищено: 29
Дочерний процесс с PID 190 похитил товар. Всего похищено: 30
Дочерний процесс с PID 188 завершил работу. Всего похищено: 30, Общая стоимость: 7712
Дочерний процесс с PID 189 завершил работу. Всего похищено: 30, Общая стоимость: 8376
Дочерний процесс с PID 190 завершил работу. Всего похищено: 30, Общая стоимость: 8844
```

## Код на 6 баллов (prog_6.c)
### с использованием "Множество процессов взаимодействуют с использованием неименованных POSIX семафоров расположенных в разделяемой".
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <semaphore.h>
#include <sys/wait.h>

#define MAX_STOLEN_ITEMS 10 // Максимальное количество похищенных товаров

typedef struct
{
    int items; // Количество похищенных товаров
    int value; // Общая стоимость похищенных товаров
} StolenGoods;

int main()
{
    // Создание неименованного POSIX семафора
    sem_t semaphore;
    if (sem_init(&semaphore, 1, 1) == -1)
    {
        perror("Ошибка создания семафора");
        exit(EXIT_FAILURE);
    }

    // Создание разделяемой памяти для хранения похищенного имущества
    int shm_fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0644);
    if (shm_fd == -1)
    {
        perror("Ошибка создания разделяемой памяти");
        sem_destroy(&semaphore);
        exit(EXIT_FAILURE);
    }
    ftruncate(shm_fd, sizeof(StolenGoods));
    StolenGoods *stolen_goods = (StolenGoods *)mmap(NULL, sizeof(StolenGoods), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (stolen_goods == MAP_FAILED)
    {
        perror("Ошибка отображения разделяемой памяти");
        sem_destroy(&semaphore);
        shm_unlink("/my_shm");
        close(shm_fd);
        exit(EXIT_FAILURE);
    }

    // Создание дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        pid_t pid = fork();
        if (pid == -1)
        {
            perror("Ошибка создания дочернего процесса");
            sem_destroy(&semaphore);
            shm_unlink("/my_shm");
            close(shm_fd);
            exit(EXIT_FAILURE);
        }
        else if (pid == 0)
        {
            // Код дочернего процесса
            srand(getpid());
            int stolen_items = 0;
            int total_value = 0;

            // Взаимодействие с использованием неименованных семафоров и разделяемой памяти
            while (stolen_items < MAX_STOLEN_ITEMS)
            {
                // Взаимодействие с семафором: ожидание освобождения
                sem_wait(&semaphore);

                // Доступ и модификация разделяемой памяти
                stolen_goods->items++;
                stolen_goods->value += rand() % 101; // Генерация случайной стоимости от 0 до 100

                // Взаимодействие с семафором: освобождение
                sem_post(&semaphore);

                printf("Дочерний процесс с PID %d похитил товар. Всего похищено: %d\n", getpid(), stolen_goods->items);

                stolen_items++;
                total_value += stolen_goods->value;

                // Задержка между похищениями
                usleep(500000); // 500 миллисекунд
            }

            printf("Дочерний процесс с PID %d завершился. Всего похищено: %d, Общая стоимость: %d\n", getpid(), stolen_goods->items, total_value);

            // Освобождение ресурсов
            munmap(stolen_goods, sizeof(StolenGoods));
            sem_destroy(&semaphore);
            close(shm_fd);
            exit(EXIT_SUCCESS);
        }
    }

    // Ожидание завершения всех дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        wait(NULL);
    }

    // Вывод результатов
    printf("Программа завершила работу. Всего похищено: %d, Общая стоимость: %d\n", stolen_goods->items, stolen_goods->value);

    // Освобождение ресурсов
    munmap(stolen_goods, sizeof(StolenGoods));
    sem_destroy(&semaphore);
    shm_unlink("/my_shm");
    close(shm_fd);
    exit(EXIT_SUCCESS);
}
```

## Вывод:
```
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 28
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 29
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 30
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 31
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 32
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 33
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 34
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 35
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 36
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 37
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 38
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 39
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 40
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 41
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 42
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 43
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 44
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 45
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 46
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 47
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 48
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 50
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 49
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 51
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 52
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 53
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 54
Дочерний процесс с PID 2612 похитил товар. Всего похищено: 55
Дочерний процесс с PID 2611 похитил товар. Всего похищено: 56
Дочерний процесс с PID 2613 похитил товар. Всего похищено: 57
Дочерний процесс с PID 2611 завершился. Всего похищено: 57, Общая стоимость: 21848
Дочерний процесс с PID 2612 завершился. Всего похищено: 57, Общая стоимость: 22168
Дочерний процесс с PID 2613 завершился. Всего похищено: 57, Общая стоимость: 22542
Программа завершила работу. Всего похищено: 57, Общая стоимость: 2773
```


## Программа на 7 баллов:
### POSIX. В программе запускается несколько процессов, которые выполняют заданную задачу!

``` C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAX_STOLEN_ITEMS 10

    typedef struct
{
    int items;
    int value;
} StolenGoods;

int main()
{
    // Создание именованного POSIX семафора
    sem_t *semaphore = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);
    if (semaphore == SEM_FAILED)
    {
        perror("Ошибка создания семафора");
        exit(EXIT_FAILURE);
    }

    // Создание разделяемой памяти для хранения похищенного имущества
    int shm_fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0644);
    if (shm_fd == -1)
    {
        perror("Ошибка создания разделяемой памяти");
        sem_unlink("/my_semaphore");
        sem_close(semaphore);
        exit(EXIT_FAILURE);
    }
    ftruncate(shm_fd, sizeof(StolenGoods));
    StolenGoods *stolen_goods = (StolenGoods *)mmap(NULL, sizeof(StolenGoods), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (stolen_goods == MAP_FAILED)
    {
        perror("Ошибка отображения разделяемой памяти");
        sem_unlink("/my_semaphore");
        sem_close(semaphore);
        shm_unlink("/my_shm");
        close(shm_fd);
        exit(EXIT_FAILURE);
    }

    // Создание дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        pid_t pid = fork();
        if (pid == -1)
        {
            perror("Ошибка создания дочернего процесса");
            sem_unlink("/my_semaphore");
            sem_close(semaphore);
            shm_unlink("/my_shm");
            close(shm_fd);
            exit(EXIT_FAILURE);
        }
        else if (pid == 0)
        {
            // Код дочернего процесса
            srand(getpid());
            int stolen_items = 0;
            int total_value = 0;

            // Взаимодействие с использованием именованных семафоров и разделяемой памяти
            while (stolen_items < MAX_STOLEN_ITEMS)
            {
                // Взаимодействие с семафором: ожидание освобождения
                sem_wait(semaphore);

                // Доступ и модификация разделяемой памяти
                stolen_goods->items++;
                stolen_goods->value += rand() % 101; // Генерация случайной стоимости от 0 до 100

                // Взаимодействие с семафором: освобождение
                sem_post(semaphore);

                printf("Процесс %d: Украдено %d предметов. Общая стоимость: %d\n", getpid(), stolen_goods->items, stolen_goods->value);
                stolen_items++;
                usleep(500000); 
            }

            // Завершение работы дочернего процесса
            munmap(stolen_goods, sizeof(StolenGoods));
            exit(EXIT_SUCCESS);
        }
    }

    // Ожидание завершения всех дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        wait(NULL);
    }

    // Закрытие и освобождение ресурсов
    sem_unlink("/my_semaphore");
    sem_close(semaphore);
    munmap(stolen_goods, sizeof(StolenGoods));
    shm_unlink("/my_shm");
    close(shm_fd);

    return 0;
}
```

## Вывод программы:

```
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 1
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 2
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 3
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 4
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 5
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 6
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 7
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 8
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 9
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 10
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 11
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 12
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 13
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 14
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 15
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 16
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 17
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 18
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 19
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 20
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 21
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 22
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 23
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 24
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 25
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 26
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 27
Дочерний процесс с PID 2671 похитил товар. Всего похищено: 28
Дочерний процесс с PID 2672 похитил товар. Всего похищено: 29
Дочерний процесс с PID 2673 похитил товар. Всего похищено: 30
Дочерний процесс с PID 2671 завершился. Всего похищено: 30, Общая стоимость: 8033
Дочерний процесс с PID 2672 завершился. Всего похищено: 30, Общая стоимость: 8591
Дочерний процесс с PID 2673 завершился. Всего похищено: 30, Общая стоимость: 9080
Программа завершила работу. Всего похищено: 30, Общая стоимость: 1601
```

## Код на 8 баллов (prog_8.c)

``` C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/wait.h>

// Ключи для разделяемой памяти и семафора
#define SHM_KEY 1234
#define SEM_KEY 5678

// Структура для хранения похищенного имущества
typedef struct
{
    int items;
    int value;
} StolenGoods;

// Функция для ожидания освобождения семафора
void sem_wait(int sem_id)
{
    struct sembuf sem_op = {0, -1, 0};
    semop(sem_id, &sem_op, 1);
}

// Функция для освобождения семафора
void sem_post(int sem_id)
{
    struct sembuf sem_op = {0, 1, 0};
    semop(sem_id, &sem_op, 1);
}

int main()
{
    // Создание и инициализация семафора
    int sem_id = semget(SEM_KEY, 1, IPC_CREAT | 0666);
    if (sem_id == -1)
    {
        perror("Ошибка создания семафора");
        exit(EXIT_FAILURE);
    }
    union semun
    {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
        struct seminfo *__buf;
    } sem_arg;
    sem_arg.val = 1; // Устанавливаем начальное значение семафора
    semctl(sem_id, 0, SETVAL, sem_arg);

    // Создание и инициализация разделяемой памяти
    int shm_id = shmget(SHM_KEY, sizeof(StolenGoods), IPC_CREAT | 0666);
    if (shm_id == -1)
    {
        perror("Ошибка создания разделяемой памяти");
        semctl(sem_id, 0, IPC_RMID); // Удаляем семафор
        exit(EXIT_FAILURE);
    }
    StolenGoods *stolen_goods = (StolenGoods *)shmat(shm_id, NULL, 0);
    if (stolen_goods == (void *)-1)
    {
        perror("Ошибка отображения разделяемой памяти");
        semctl(sem_id, 0, IPC_RMID);    // Удаляем семафор
        shmctl(shm_id, IPC_RMID, NULL); // Удаляем разделяемую память
        exit(EXIT_FAILURE);
    }

    // Создание дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        pid_t pid = fork();
        if (pid == -1)
        {
            perror("Ошибка создания дочернего процесса");
            semctl(sem_id, 0, IPC_RMID);    // Удаляем семафор
            shmctl(shm_id, IPC_RMID, NULL); // Удаляем разделяемую память
            exit(EXIT_FAILURE);
        }
        else if (pid == 0)
        {
            // Код дочернего процесса
            int id = getpid();
            int total_price = 0;
            printf("Дочерний процесс %d запущен\n", id);
            for (int j = 0; j < 5; j++)
            {
                sem_wait(sem_id); // Ожидание освобождения семафора

                int sum = rand() % 101;
                // Взаимодействие с разделяемой памятью
                stolen_goods->items++;
                stolen_goods->value += sum;
                total_price += sum;

                printf("Дочерний процесс %d украл %d предметов на сумму %d\n", id, stolen_goods->items, stolen_goods->value);

                sem_post(sem_id); // Освобождение семафора
                sleep(1);         // Пауза между кражами
            }
            printf("Дочерний процесс %d завершен. Общая стоимость: %d\n", id, total_price);
            exit(EXIT_SUCCESS);
        }
    }

    // Ожидание завершения всех дочерних процессов
    for (int i = 0; i < 3; i++)
    {
        wait(NULL);
    }

    // Удаление разделяемой памяти и семафора
    shmdt(stolen_goods);
    shmctl(shm_id, IPC_RMID, NULL);
    semctl(sem_id, 0, IPC_RMID);
    return 0;
}

```

Вывод программы:

```
Дочерний процесс 2776 запущен
Дочерний процесс 2776 украл 1 предметов на сумму 32
Дочерний процесс 2777 запущен
Дочерний процесс 2777 украл 2 предметов на сумму 64
Дочерний процесс 2778 запущен
Дочерний процесс 2778 украл 3 предметов на сумму 96
Дочерний процесс 2776 украл 4 предметов на сумму 128
Дочерний процесс 2777 украл 5 предметов на сумму 160
Дочерний процесс 2778 украл 6 предметов на сумму 192
Дочерний процесс 2776 украл 7 предметов на сумму 246
Дочерний процесс 2777 украл 8 предметов на сумму 300
Дочерний процесс 2778 украл 9 предметов на сумму 354
Дочерний процесс 2776 украл 10 предметов на сумму 366
Дочерний процесс 2777 украл 11 предметов на сумму 378
Дочерний процесс 2778 украл 12 предметов на сумму 390
Дочерний процесс 2776 украл 13 предметов на сумму 442
Дочерний процесс 2777 украл 14 предметов на сумму 494
Дочерний процесс 2778 украл 15 предметов на сумму 546
Дочерний процесс 2776 завершен. Общая стоимость: 182
Дочерний процесс 2777 завершен. Общая стоимость: 182
Дочерний процесс 2778 завершен. Общая стоимость: 182

```